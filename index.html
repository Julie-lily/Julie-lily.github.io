<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>Smile~~ | Julie's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Julie's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Julie's Blog</div><div id="site-sub-title">Smile~~</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/12/MarkDown%E5%9F%BA%E7%A1%80%E5%86%99%E6%B3%95/">MarkDown基础写法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-12</time><div class="content"><h2 id="MarkDown添加图片的方式"><a href="#MarkDown添加图片的方式" class="headerlink" title="MarkDown添加图片的方式"></a>MarkDown添加图片的方式</h2><ol>
<li><img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5%22%22" alt="Alt text"></li>
</ol>
<ul>
<li>Alt text:图片的alt标签，用来描述图片的关键词；</li>
<li>图片链接：可以是图片的本地地址或网址；</li>
</ul>
<ol start="2">
<li>用base64转码工具把图片转成一段字符串，然后把字符串填到基础格式中链接的那个位置；</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/11/Less%E5%92%8CSass%E7%AD%89CSS%E9%A2%84%E7%BC%96%E8%AF%91%E5%99%A8%E7%9B%B8%E5%85%B3/">Less和Sass等CSS预编译器相关</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-11</time><div class="content"><h2 id="使用Less和Sass的原因和优势"><a href="#使用Less和Sass的原因和优势" class="headerlink" title="使用Less和Sass的原因和优势"></a>使用Less和Sass的原因和优势</h2><p>学习网站：<a target="_blank" rel="noopener" href="https://less.bootcss.com/">https://less.bootcss.com/</a></p>
<p><strong>Less</strong>是一种CSS的预编译语言，是一种动态样式语言，对CSS赋予了动态语言的特性，如变量、继承、运算、函数；</p>
<hr>
<p><strong>Sass</strong>同上，是一种动态样式语言，Sass语法属于缩排语法；</p>
<hr>
<p><strong>使用原因：</strong><br>（1）可以提升编写CSS的效率，减少重复性代码；</p>
<p>（2）结构清晰，便于扩展；</p>
<p>（3）实现多重继承；</p>
<h2 id="Less安装"><a href="#Less安装" class="headerlink" title="Less安装"></a>Less安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i less -g</span><br><span class="line"></span><br><span class="line">lessc test.less //lessc命令用于编译Less文件</span><br></pre></td></tr></table></figure>

<h2 id="Less基本写法"><a href="#Less基本写法" class="headerlink" title="Less基本写法"></a>Less基本写法</h2><ol>
<li><p>Less变量：@width:10px  (兼容性)</p>
</li>
<li><p>混合（Mixins):是一种将一组属性从一个规则集混入到另一个规则集的方法；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.header&#123;</span><br><span class="line">    border:solid 1px black;</span><br><span class="line">    font-size:18px;</span><br><span class="line">&#125;</span><br><span class="line">其他类中混入这些属性,只需要像函数一样调用</span><br><span class="line">.top&#123;</span><br><span class="line">    .header();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>嵌套（Nesting）：嵌套代替层叠，或与层叠结合使用；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#header &#123;</span><br><span class="line">  color: black;</span><br><span class="line"></span><br><span class="line">  伪类</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  子元素选择器</span><br><span class="line">  &amp; &gt; span &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>导入（import）：导入另一个Less文件；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//theme.less</span><br><span class="line">定义主题</span><br><span class="line">@themeColor:#eee;</span><br><span class="line">@changeColor:#666;</span><br><span class="line"></span><br><span class="line">//main.less</span><br><span class="line">@import &quot;theme&quot;;</span><br><span class="line"></span><br><span class="line">.header&#123;</span><br><span class="line">    color:@themeColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>CSS Modules:借助Webpack，自动生成唯一的类名，不会和其他模块的命名产生冲突；</p>
<ul>
<li>需要使用变量的方式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import style from &#x27;./style.less&#x27;</span><br><span class="line"></span><br><span class="line">&lt;div className=&#123;style.top&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li>CSS Modules会转换所有的类名和ID名，如果有不想转换，可以使用 :global()；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:global(#app) &#123;</span><br><span class="line">  background-color: #eee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>Less基于JavaScript，是在客户端处理的</code><br><code>Sass基于Ruby的，是在服务器端处理的</code></p>
<h2 id="Sass基本写法"><a href="#Sass基本写法" class="headerlink" title="Sass基本写法"></a>Sass基本写法</h2><ol>
<li>变量：$</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/11/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/">Git操作指南</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-11</time><div class="content"><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><ul>
<li>配置全局的name和email<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “  “</span><br><span class="line">git config --global user.email “   “</span><br></pre></td></tr></table></figure></li>
<li>生成SSH公钥<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “user.email “</span><br></pre></td></tr></table></figure></li>
<li>进入github配置密钥<br>拷贝C:/Users/Administrator/.ssh/id_rsa.pub文件中的所有内容到SSH keys</li>
</ul>
<p><code>.gitignore 用来告诉Git忽略哪些文件，不要将其加入到追踪列表</code></p>
<h2 id="Git常见操作指令"><a href="#Git常见操作指令" class="headerlink" title="Git常见操作指令"></a>Git常见操作指令</h2><p>(1) git init 初始化一个本地仓库，生成一个.git文件</p>
<p>(2) git clone [<del>ssh://</del>]  拷贝一个远程仓库</p>
<p>(3) git add [file1][file2]…  添加文件到暂存区  </p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add a.txt readme.md</span><br><span class="line">git add [dir]/         添加指定目录到暂存区</span><br><span class="line">git add .            添加当前目录下的所有文件到暂存区</span><br></pre></td></tr></table></figure>
</code></pre>
<p>(4) git status 查看仓库当前的状态，显示有变更的文件 </p>
<p>(5) git commit 提交暂存区到本地仓库<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message]    message为备注信息</span><br><span class="line">git commit [file1][file2]...    提交暂存区的指定文件到仓库区</span><br><span class="line">git commit -a             -a设置修改文件后，不需要执行git add命令，即可提交</span><br></pre></td></tr></table></figure></p>
<p>(6) git remote add origin ~  //要添加一个新的远程仓库</p>
<p>(7) git push origin master   //上传至远程仓库</p>
<p>(8) git rm [file1]      //删除某个文件或文件夹<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   git rm -r --cached  a/1.txt      // -r参数删除目录，--cached保留本地文件</span><br><span class="line">   git commit -m “删除a目录下的1.txt文件”</span><br><span class="line">   git push //上传至远程仓库</span><br><span class="line"></span><br><span class="line">(9) git mv -f  oldname  newname  //修改某个文件的名字</span><br><span class="line"></span><br><span class="line">(10) git fetch  用于从远程获取代码库</span><br></pre></td></tr></table></figure><br>    git fetch [alias]                  git fetch origin<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(11) git merge  从远程仓库提取数据并尝试合并到当前分支，将更新同步到本地：</span><br></pre></td></tr></table></figure><br>    git merge [alias]/[branch]    git merge origin/master<br>    合并develop到master<br>    git checkout master<br>    git merge develop<br>    例如：合并develop到master<br>    git checkout master<br>    git merge develop<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(12) git pull --rebase origin master  //rebase命令将提交到某一分支上的所有修改移至另一分支上;</span><br></pre></td></tr></table></figure><br>    git pull  =  git fetch  +  git merge FETCH_HEAD<br>    git pull –rebase = git fetch + git rebase FETCH_HEAD<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rebase没有产生新的节点，使用rebase的git演进路线(提交树)是一直向前的;而merge是产生一个新节点</span><br><span class="line">rebase 操作如果冲突的话，会中断rebase，同时会提示去解决冲突。解决冲突后, 再执行 git rebase –continue 继续操作，再push；</span><br><span class="line"></span><br><span class="line">(13) git branch  查看分支</span><br></pre></td></tr></table></figure><br>    git branch [“newbranch”] 新建一个分支<br>    git checkout  [“branch”]  切换分支<br>    删除之前需要先切换到其他分支<br>    git branch -d [“branch”]  删除分支</p>
<pre><code>git push -d [“ ”] 删除远程分支
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(14) 如果我们错误地添加了文件或改动到暂存区，可以执行命令撤销</span><br><span class="line">git reset HEAD index.html</span><br><span class="line">这里的HEAD就是指向当前分支的一个指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(15)git clone 不清楚如何克隆仓库中的单个或多个文件夹，而不是全部的仓库:</span><br><span class="line">   例如：test仓库https://github.com/~，要git clone一下test仓库里面的code / react_demo/prepare/hello-comment子目录:</span><br></pre></td></tr></table></figure>
git config core.sparsecheckout true //设置允许克隆子目录
echo &#39;code/react_demo/prepare/hello-comment*&#39; &gt;&gt;  .git/info/sparse-checkout  //设置要克隆的仓库的子目录路径
git remote add origin [git@~要克隆的仓库地址]
git pull origin master //下载到本地
```
</code></pre>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/10/Java%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">Java相关知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-10</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/10/Python%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%BB%A4%E6%B3%A2%EF%BC%88%E5%9F%BA%E4%BA%8Escipy/">Python实现信号滤波（基于scipy)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-10</time><div class="content"><h2 id="基于scipy模块使用Python实现简单滤波处理"><a href="#基于scipy模块使用Python实现简单滤波处理" class="headerlink" title="基于scipy模块使用Python实现简单滤波处理"></a>基于scipy模块使用Python实现简单滤波处理</h2><p>作用：去除干扰信号</p>
<ol>
<li><p>低通滤波：去除高于某一阈值频率的信号；</p>
</li>
<li><p>高通滤波：去除低于某一频率的信号；</p>
</li>
<li><p>带通滤波：类似低通高通的结合保留中间频率信号；</p>
</li>
<li><p>带阻滤波器：低通高通的结合只是过滤掉的是中间部分；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1) 滤波器构造函数:scipy.signal.butter(N, Wn, btype=&#x27;low&#x27;, analog=False, output=&#x27;ba&#x27;)</span><br><span class="line">N:滤波器的阶数</span><br><span class="line">Wn：归一化截止频率(计算公式Wn=2*截止频率/采样频率)</span><br><span class="line">btype : 滤波器类型&#123;‘lowpass’, ‘highpass’, ‘bandpass’, ‘bandstop’&#125;</span><br><span class="line">output : 输出类型&#123;‘ba’, ‘zpk’, ‘sos’&#125;</span><br><span class="line"></span><br><span class="line">(2) 滤波函数：scipy.signal.lfilter(b, a, x, axis=-1, zi=None)</span><br><span class="line">使用IIR或FIR过滤器沿one-dimension过滤数据</span><br></pre></td></tr></table></figure></li>
</ol>
<p>举例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from scipy import signal</span><br><span class="line">b, a = signal.butter(8, 0.2, &#x27;highpass&#x27;)   #配置滤波器 8 表示滤波器的阶数</span><br><span class="line">filtedData = signal.filtfilt(b, a, data)   #data为要过滤的信号</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">计算机网络相关知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-06</time><div class="content"><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层</p>
<h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><p>应用层协议<br><strong>超文本传输协议</strong>：用于服务器传输超文本到本地浏览器的传输协议；</p>
<p>（1）HTTPS需要申请CA证书或自制证书；</p>
<p>（2） HTTP是明文传输；HTTPS具有安全性的SSL加密；</p>
<p>（3）端口号不一致，HTTP是80端口；HTTPS是443;</p>
<h2 id="HTTP请求方式，GET和POST的区别"><a href="#HTTP请求方式，GET和POST的区别" class="headerlink" title="HTTP请求方式，GET和POST的区别"></a>HTTP请求方式，GET和POST的区别</h2><p> 本质上都是<strong>TCP连接</strong>，但由于HTTP的规定和浏览器/服务器的限制，导致它们在应用中的不同；<br> （从技术层面上讲，GET可加上request body，但不保证能被接受，POST同理，可带上URL参数</p>
<p>（1）GET请求参数放在URL中；POST请求参数放在request body上；</p>
<p>（2）对于参数类型，GET只接受ASCII字符；POST没有限制；</p>
<p>（3）GET没有POST安全，因为参数直接暴露在URL；</p>
<p>（4）GET请求可缓存，用于请求数据；POST请求不会被缓存，可创建或更新数据；</p>
<h2 id="对称加密和非对称加密的区别"><a href="#对称加密和非对称加密的区别" class="headerlink" title="对称加密和非对称加密的区别"></a>对称加密和非对称加密的区别</h2><h2 id="http缓存机制-浏览器缓存机制"><a href="#http缓存机制-浏览器缓存机制" class="headerlink" title="http缓存机制(浏览器缓存机制)"></a>http缓存机制(浏览器缓存机制)</h2><ol>
<li><p>强缓存</p>
</li>
<li><p>协商缓存</p>
</li>
</ol>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><h2 id="HTTP请求和响应头部有哪些信息？"><a href="#HTTP请求和响应头部有哪些信息？" class="headerlink" title="HTTP请求和响应头部有哪些信息？"></a>HTTP请求和响应头部有哪些信息？</h2><p><code>请求头：</code></p>
<ul>
<li>Accept: 浏览器能够处理的内容类型；</li>
<li>Accept-Charset: 浏览器能够显示的字符集；</li>
<li>Accept-Encoding: </li>
<li>Accept-Language:</li>
<li>Connection: 连接的类型，例如：keep-alive</li>
<li>Cookie:</li>
<li>Host: 发出请求的页面所在域</li>
<li>Referer：发出请求的页面的URL</li>
</ul>
<p><code>响应头：</code></p>
<ul>
<li>Cache-Control: 控制HTTP缓存</li>
</ul>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>传输层协议</p>
<ol>
<li>区别：</li>
</ol>
<p>（1）TCP面向连接；UDP无连接；</p>
<p>（2）TCP面向字节流；UDP面向报文；</p>
<p>（3）TCP首部为20字节；UDP首部为8字节；</p>
<p>（4）TCP提供可靠的传输服务，传输的数据无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付；</p>
<ol start="2">
<li>应用场景：</li>
</ol>
<ul>
<li>传输控制协议TCP：用于HTTP、HTTPS、FTP等传输协议，POP、SMTP邮件协议；</li>
<li>用户数据报协议UDP：用于语音、视频等；</li>
</ul>
<h2 id="TCP三次握手和四次挥手的过程"><a href="#TCP三次握手和四次挥手的过程" class="headerlink" title="TCP三次握手和四次挥手的过程"></a>TCP三次握手和四次挥手的过程</h2><h2 id="sessionStorage、localStorage和cookie的区别，以及操作api"><a href="#sessionStorage、localStorage和cookie的区别，以及操作api" class="headerlink" title="sessionStorage、localStorage和cookie的区别，以及操作api"></a>sessionStorage、localStorage和cookie的区别，以及操作api</h2><h2 id="cookie、session和token的区别"><a href="#cookie、session和token的区别" class="headerlink" title="cookie、session和token的区别"></a>cookie、session和token的区别</h2><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h2 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/06/webpack%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">webpack相关知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-06</time><div class="content"><h2 id="前端路由：页面跳转的URL规则匹配由前端来控制"><a href="#前端路由：页面跳转的URL规则匹配由前端来控制" class="headerlink" title="前端路由：页面跳转的URL规则匹配由前端来控制"></a>前端路由：页面跳转的URL规则匹配由前端来控制</h2><h2 id="webpack的构建流程"><a href="#webpack的构建流程" class="headerlink" title="webpack的构建流程"></a>webpack的构建流程</h2><h2 id="webpack中loader和plugin的区别"><a href="#webpack中loader和plugin的区别" class="headerlink" title="webpack中loader和plugin的区别"></a>webpack中loader和plugin的区别</h2><h2 id="webpack自动化部署"><a href="#webpack自动化部署" class="headerlink" title="webpack自动化部署"></a>webpack自动化部署</h2><h2 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h2><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/06/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">js基础知识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-06</time><div class="content"><h2 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h2><p>基础数据类型：</p>
<ol>
<li>Number：包括整数和浮点数</li>
</ol>
<ul>
<li>isNaN()函数用于检查是否为非数字值，例如：isNaN(123) ===&gt;false</li>
<li>NaN!=NaN</li>
</ul>
<ol start="2">
<li>String：字符串有length属性</li>
</ol>
<ul>
<li>转型函数String():适用于任何数据类型，例如：String(null)===&gt;’null’</li>
<li>toString()方法：null和undefined没有toString()方法</li>
</ul>
<ol start="3">
<li><p>Boolean</p>
</li>
<li><p>Undefined</p>
</li>
<li><p>Null</p>
</li>
<li><p>Symbol(独一无二的值)</p>
</li>
<li><p>BigInt</p>
</li>
</ol>
<p>复杂数据类型：Object</p>
<h2 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h2><ol>
<li>typeof<br>例如： </li>
</ol>
<ul>
<li>typeof 123 ==”string”</li>
<li>typeof null == “object”</li>
</ul>
<ol start="2">
<li>instanceof:判断构造函数的原型是否在被检测对象的原型链上<br>例如：</li>
</ol>
<ul>
<li>123 instanceof Number  ; // false</li>
<li>‘foo’ instanceof String; // false</li>
</ul>
<p>原理：如何判断A是不是B的实例？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function _instanceof(a,b)&#123;</span><br><span class="line">    let L=a._proto_;</span><br><span class="line">    let R =b.prototype;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if(L==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L==R)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            L=L._proto_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.prototype.toString.call()   “[object Object]”</li>
</ol>
<ol start="4">
<li>constructor：不能判断null和undeifned</li>
</ol>
<h2 id="JavaScript的内置对象"><a href="#JavaScript的内置对象" class="headerlink" title="JavaScript的内置对象"></a>JavaScript的内置对象</h2><ul>
<li>数据封装类对象: Object Array Boolean Number String</li>
<li>其他对象：Function Arguments Math Date RegExp Error</li>
</ul>
<h2 id="js正则表达式RegExp"><a href="#js正则表达式RegExp" class="headerlink" title="js正则表达式RegExp"></a>js正则表达式RegExp</h2><ul>
<li>i 大小写不敏感</li>
<li>g 执行全局匹配</li>
</ul>
<p>RegExp.test(string):检测是否匹配，返回true或false</p>
<p>RegExp.exec(string):检索匹配结果，返回数组</p>
<p>string.match(RegExp):返回匹配的数组</p>
<p>string.replace(,)</p>
<h2 id="var、let和const的区别，变量提升"><a href="#var、let和const的区别，变量提升" class="headerlink" title="var、let和const的区别，变量提升"></a>var、let和const的区别，变量提升</h2><ol>
<li><p>var声明的变量会挂载到window上，而let和const声明的变量不会；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=100;</span><br><span class="line">console.log(a,window.a);  //100 100</span><br><span class="line"></span><br><span class="line">let b=10;</span><br><span class="line">console.log(b,window.b);  //10 undefined</span><br><span class="line"></span><br><span class="line">let c=1;</span><br><span class="line">console.log(c,window.c);  //1 undefined</span><br></pre></td></tr></table></figure></li>
<li><p>var变量存在变量提升，而let和const没有；</p>
</li>
<li><p>let和const声明形成块作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(1)&#123;</span><br><span class="line">    var a=100;</span><br><span class="line">    let b=10;</span><br><span class="line">    const c=1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a,b,c) //100 报错:b is not defined  报错：c is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>同一作用域内，let和const不可重复声明;</p>
</li>
<li><p>暂存死区；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">if(1)&#123;</span><br><span class="line">    a = 10;</span><br><span class="line">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>const一旦声明变量，必须复制，且声明后不可修改其值；</p>
</li>
</ol>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ol>
<li>this，箭头函数没有自己的this；</li>
<li>arguments，不能使用arguments，改用rest代替；</li>
<li>原型，没有prototype，无法作为构造函数；</li>
<li>yeild</li>
</ol>
<h2 id="new函数的具体实现"><a href="#new函数的具体实现" class="headerlink" title="new函数的具体实现"></a>new函数的具体实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function _new(constructor,...args)&#123;</span><br><span class="line">    let obj = &#123;&#125;;//新建一个空对象</span><br><span class="line">    obj._proto_ = constructor.prototype;//原型链连接</span><br><span class="line">    let res = constructor.apply(obj,...args);//改变this指向</span><br><span class="line">    return res instanceof Object ? res:obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p><strong>debounce（防抖）</strong>:触发高频事件后，N秒内函数只会执行一次，若N秒内再次触发高频事件，则重新计时;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(fn,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<ul>
<li>搜索框输入查询</li>
<li>浏览器窗口缩放</li>
<li>按钮提交</li>
<li>表单验证</li>
</ul>
<p><strong>throttle（节流）</strong>:高频事件多次触发，但在N秒内只会执行一次，会稀释函数的执行频率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    let timer=null;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)return false;</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;</span><br><span class="line">            fn();</span><br><span class="line">            timer=null;</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<ul>
<li>高频表单提交</li>
<li>滚动加载onScroll</li>
<li>拖拽事件</li>
</ul>
<h2 id="Array数组的常见API"><a href="#Array数组的常见API" class="headerlink" title="Array数组的常见API"></a>Array数组的常见API</h2><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><ul>
<li>for(let i=0;i &lt; arr.length;i++){}</li>
<li>forEach:不能break或return;遍历时会跳过空值;</li>
<li>for in:会跳过空值</li>
<li>for of:</li>
</ul>
<h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ul>
<li>for in</li>
<li>for of Object.keys(obj)</li>
<li>for of Object.values(obj)</li>
<li>for of Object.entries(obj)</li>
</ul>
<h2 id="for-in-、for-of-、Object-keys-的区别"><a href="#for-in-、for-of-、Object-keys-的区别" class="headerlink" title="for in 、for of 、Object.keys()的区别"></a>for in 、for of 、Object.keys()的区别</h2><p><code>return 语句只能在函数体中，否则会报错</code></p>
<ul>
<li>for in：可遍历数组或对象的属性（随机遍历）</li>
</ul>
<ol>
<li><p>遍历数组：除了会遍历数组元素，还会遍历自定义可枚举的属性，以及原型链上可枚举的属性；</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.sayLength = function()&#123;</span><br><span class="line">    console.log(this.length);</span><br><span class="line">&#125;//原型链上</span><br><span class="line"></span><br><span class="line">let arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];</span><br><span class="line">arr.name = &#x27;数组&#x27;; //自定义属性</span><br><span class="line"></span><br><span class="line">Object.defineProperties(arr,&#123;</span><br><span class="line">    type:&#123;</span><br><span class="line">        value:true,</span><br><span class="line">        writable:true,</span><br><span class="line">        enumerable:true</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for(let i in arr)&#123;</span><br><span class="line">    console.log(i); //0,1,2,3,name,type,sayLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>Object.keys():遍历对象属性<br><code>和 for in 的区别在于：不能遍历原型链上的属性</code></li>
</ul>
<ul>
<li>for of（ES6新语法）:可遍历拥有iterator迭代器对象的集合；支持遍历<strong>数组</strong>、<strong>类对象</strong>、<strong>字符串</strong>、<strong>Set对象</strong>、<strong>Map对象</strong>；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [0,1,2,3];</span><br><span class="line">for(let i of arr)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person=&#123;</span><br><span class="line">    name:&#x27;1&#x27;,</span><br><span class="line">    age:12</span><br><span class="line">&#125;</span><br><span class="line">for(let key of Object.keys(person))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">for(let [key,value] of Object.entries(person))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象的浅拷贝和深拷贝"><a href="#对象的浅拷贝和深拷贝" class="headerlink" title="对象的浅拷贝和深拷贝"></a>对象的浅拷贝和深拷贝</h2><h2 id="ES异步编程的发展史"><a href="#ES异步编程的发展史" class="headerlink" title="ES异步编程的发展史"></a>ES异步编程的发展史</h2><h2 id="Promise的作用及api"><a href="#Promise的作用及api" class="headerlink" title="Promise的作用及api"></a>Promise的作用及api</h2><p><strong>作用：</strong> Promise用于解决回调地狱（嵌套过多）;</p>
<ul>
<li>Promise.all()：只在所有请求成功之后才会做出响应<br>应用场景：发起多个请求时</li>
</ul>
<ul>
<li>Promise.race():</li>
</ul>
<ul>
<li>Promise.finally():</li>
</ul>
<h2 id="Generator和Async的区别"><a href="#Generator和Async的区别" class="headerlink" title="Generator和Async的区别"></a>Generator和Async的区别</h2><h2 id="实现继承的方式"><a href="#实现继承的方式" class="headerlink" title="实现继承的方式"></a>实现继承的方式</h2><ol>
<li><p>原型继承</p>
</li>
<li><p>构造继承</p>
</li>
<li><p>组合继承</p>
</li>
<li><p>寄生式继承</p>
</li>
<li><p>寄生组合式继承</p>
</li>
</ol>
<h2 id="图片懒加载的实现，以及原因"><a href="#图片懒加载的实现，以及原因" class="headerlink" title="图片懒加载的实现，以及原因"></a>图片懒加载的实现，以及原因</h2><p>intersectionObserver</p>
<h2 id="闭包的含义及作用"><a href="#闭包的含义及作用" class="headerlink" title="闭包的含义及作用"></a>闭包的含义及作用</h2><p>闭包：有权访问另一个函数作用域的函数；<br>作用：为了设计私有的方法和变量；<br>优点：<br>（1）避免全局污染，隐藏变量；</p>
<p>缺点：<br>（1）常驻内存，使用不当容易造成内存泄漏；<br>（2）内存浪费；</p>
<h2 id="原型以及原型链"><a href="#原型以及原型链" class="headerlink" title="原型以及原型链"></a>原型以及原型链</h2><ul>
<li>原型的概念：每一个javascript对象（除了null）创建时，就会与之关联另一个对象，这个对象即原型；每个对象都会从原型中“继承”属性；</li>
</ul>
<p><code>当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj);</code></p>
<p><img src="/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<p>（1）每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针constructor；<br>（2）实例都包含一个指向原型对象的内部指针；</p>
<h2 id="作用域，又称为作用上下文"><a href="#作用域，又称为作用上下文" class="headerlink" title="作用域，又称为作用上下文"></a>作用域，又称为作用上下文</h2><p><strong>作用域</strong>的作用是用于解析标识符，隔离变量；</p>
<p>当函数被创建（定义）时，会将this,arguments,命名参数和该函数中局部变量都保存在当前作用域内；</p>
<p><strong>作用域链</strong>的作用：保证对执行环境有权访问的所有变量和函数的有序访问；</p>
<p>当执行一段JS代码时，JS引擎会创建一个作用域，在页面加载后首先会创建一个全局作用域，然后每执行一个函数，就会建立一个对应的作用域，从而形成一个作用域链。</p>
<p>执行环境(execution context)定义了变量或者函数有权访问的其他数据，每个执行环境都有一个与之关联的<code>变量对象</code>(variable object)，执行环境中定义的变量和函数就保存在这个变量对象中；<br>全局执行环境是最外围的一个执行环境，通常被认为是window对象;<br>执行环境和变量对象在<code>运行函数</code>时生成;<br>执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)</p>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li>new绑定</li>
</ol>
<h2 id="事件循环机制event-loop"><a href="#事件循环机制event-loop" class="headerlink" title="事件循环机制event loop"></a>事件循环机制event loop</h2><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>//取消事件冒泡</p>
<ul>
<li><p>e.stopPropagation()</p>
</li>
<li><p>e.cancelBubble = true</p>
</li>
</ul>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ol>
<li><p>标记清除</p>
</li>
<li><p>引用计数</p>
</li>
</ol>
<h2 id="常见的内存泄漏的原因"><a href="#常见的内存泄漏的原因" class="headerlink" title="常见的内存泄漏的原因"></a>常见的内存泄漏的原因</h2><ol>
<li>全局变量</li>
<li>闭包</li>
<li>循环引用</li>
<li>dom清除或删除时，绑定的事件未清除</li>
<li>未及时清除计时器或回调函数</li>
</ol>
<h2 id="前端常见的攻击手段"><a href="#前端常见的攻击手段" class="headerlink" title="前端常见的攻击手段"></a>前端常见的攻击手段</h2><ul>
<li><code>XSS预防</code>（跨站脚本攻击Cross-Site Scripting）：原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码,当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的;</li>
</ul>
<ol>
<li><p>非持久型XSS（反射型XSS）:一般是通过向用户发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意脚本代码参数被解析、执行；</p>
</li>
<li><p>持久型XSS(存储型XSS)：一般存在与form表单提交等交互功能中，比如文章留言，提交文本信息等；</p>
</li>
</ol>
<p>黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行；</p>
<p><strong>防御手段</strong>：</p>
<ol>
<li>转义字符，用户的输入永远不可信；</li>
<li>服务端设置Cookie的HttpOnly属性，预防XSS攻击获取cookie；</li>
<li>CSP建立白名单，明确哪些外部资源可以加载和执行；</li>
</ol>
<hr>
<ul>
<li><code>CSRF预防(跨站请求伪造)</code>:是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作;<br>举例说明CSRF攻击的具体过程，攻击者能够跨站攻击的本质是什么？CSRF怎么防御?</li>
</ul>
<p>完成 CSRF 攻击必须要有三个条件：</p>
<ul>
<li>用户已经登录了站点 A，并在本地记录了 cookie;</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A);</li>
<li>站点 A 没有做任何 CSRF 防御;</li>
</ul>
<p><strong>防御手段</strong></p>
<ol>
<li>设置验证码，强制用户进行交互；</li>
<li>Referer Check，通过检查请求的来源来防御CSRF攻击，在Http头中有一个字段referer，记录了该http请求的来源地址；</li>
<li>token验证，发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token；</li>
</ol>
<p>服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等；</p>
<hr>
<ul>
<li><code>SQL注入</code>：构建SQL查询</li>
</ul>
<p>所谓的万能密码,本质上就是SQL注入的一种利用方式；</p>
<p><strong>防御</strong>：</p>
<ul>
<li>严格限制Web应用的数据库操作权限；</li>
<li>后端代码检查输入的数据是否符合预期，使用正则表达式匹配处理；</li>
<li>对进入数据库的特殊字符（’,”,&lt;,&gt;,&amp;,*,;等）进行转义处理或编码处理；</li>
</ul>
<h2 id="浏览器的同源策略，跨域怎么解决，JsonP"><a href="#浏览器的同源策略，跨域怎么解决，JsonP" class="headerlink" title="浏览器的同源策略，跨域怎么解决，JsonP"></a>浏览器的同源策略，跨域怎么解决，JsonP</h2><p>JsonP浏览器返回的数据是什么，回调函数写在哪里？script标签的src里面</p>
<p><strong>同源策略：</strong>是一种约定，是浏览器最核心也最基本的安全功能;会阻止一个域的javascript脚本和另外一个域的内容进行交互;</p>
<ul>
<li>同源策略限制的内容：<br>（1）Cookie、localStorage、sessionStorage；<br>（2）DOM节点；<br>（3）Ajax请求；</li>
</ul>
<p><code>当协议、域名和端口任意一个不同时，就会发生跨域;</code></p>
<p><strong>跨域的解决方法：</strong><br>（1）document.domain设置，设为相同值，即可共享Cookie（适用于主域相同，子域不同的页面）;</p>
<p>（2）window.postMessage()通信<br>window.addEventListener(‘message’,function(e){</p>
<p>});</p>
<p>（3）JSONP,服务端和客户端通信跨源通信的常用方法；</p>
<ul>
<li>优点：简单适用，兼容性强</li>
<li>缺点：只支持GET请求；</li>
<li>核心思想：通过添加一个<script>元素，利用src属性不受跨域限制，在服务端连接的 参数 中加入callback函数，服务端将数据放入该回调函数中；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原生实现</span><br><span class="line">&lt;script src=&quot;http://test.com/index.html?callback=test1&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;scipt type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    //回调函数处理服务端返回数据</span><br><span class="line">    function test1(res)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（4）CORS(跨域资源共享Cross-Origin Resource Sharing)</p>
<ul>
<li>普通跨域请求：只需服务器端设置Access-Control-Allow-Origin<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务端设置</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;);</span><br><span class="line">&#x27;Access-Control-Allow-Credentials&#x27;: &#x27;true&#x27;,     // 后端允许发送Cookie</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>（5）webpack本地代理：代理服务器，转发响应，转发请求；</p>
<p>webpack.config.js中利用WebpackDevServer配置本地代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer&#123;</span><br><span class="line">     port:8080,</span><br><span class="line">     proxy:&#123;</span><br><span class="line">         &quot;/api&quot;:&#123;</span><br><span class="line">             target:&quot;http://~&quot;     //后端接口</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）Nignx反向代理：搭建一个中转 nginx 服务器，用于转发请求；在一个服务器上配置<strong>多个前缀</strong>来转发http/https请求到多个真实的服务器即可；</p>
<p>下载nginx，修改nginx目录下nginx.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>（7）websocket：是HTML5的一种持久化协议，实现浏览器和服务器的全双工通信，WebSocket基于TCP协议，在建立连接后，服务端和客户端均能主动向对方发送数据或接收数据；</p></div><a class="more" href="/2021/09/06/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more">阅读更多</a><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/05/CSS3%E7%9B%B8%E5%85%B3/">CSS3相关</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-05</time><div class="content"><h2 id="CSS3新增属性的用法："><a href="#CSS3新增属性的用法：" class="headerlink" title="CSS3新增属性的用法："></a>CSS3新增属性的用法：</h2><ol>
<li>box-shadow：阴影效果</li>
<li>box-sizing：控制盒模型的组成模式</li>
<li>border-image：图片边框</li>
<li>border-radius：圆角边框</li>
<li>text-shadow：文本阴影</li>
<li>text-overflow：文本截断</li>
<li>word-wrap：自动换行</li>
<li>opacity:透明度</li>
<li>resize：元素缩放</li>
<li>outline：外边框</li>
<li>hsl：通过色调、饱和度、亮度来指定颜色颜色值</li>
<li>hsla：在hsl的基础上增加透明度设置</li>
<li>rgba：基于rgb设置颜色，a设置透明度</li>
</ol>
<h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h2><ol>
<li>transition是过渡，只有开始和结束；animation结合keyframe(关键帧)可以设置中间帧；</li>
<li>transition需要通过hover事件或js事件配合触发；animation配合@keyframe，不需要触发事件；</li>
<li>transition只能触发一次；animation可以设置循环次数；</li>
</ol>
<h2 id="隐藏设置："><a href="#隐藏设置：" class="headerlink" title="隐藏设置："></a>隐藏设置：</h2><h3 id="display-none和visiblity-hidden以及opacity-0的区别："><a href="#display-none和visiblity-hidden以及opacity-0的区别：" class="headerlink" title="display:none和visiblity:hidden以及opacity:0的区别："></a>display:none和visiblity:hidden以及opacity:0的区别：</h3><ul>
<li>display:none</li>
</ul>
<ol>
<li>不占用空间</li>
<li>设置transition属性无效</li>
</ol>
<ul>
<li>visiblity:hidden</li>
</ul>
<ol>
<li>元素会隐藏，但依然占据空间；</li>
<li>不会触发绑定的事件；</li>
</ol>
<ul>
<li>opacity:0</li>
</ul>
<ol>
<li>透明度为0，依然占据空间；</li>
<li>可以触发绑定的事件；</li>
<li>可以使用transition属性；</li>
</ol>
<h2 id="实现水平垂直居中的方法"><a href="#实现水平垂直居中的方法" class="headerlink" title="实现水平垂直居中的方法"></a>实现水平垂直居中的方法</h2><h2 id="BFC块级格式化上下文：独立的渲染空间，不受外部布局的影响"><a href="#BFC块级格式化上下文：独立的渲染空间，不受外部布局的影响" class="headerlink" title="BFC块级格式化上下文：独立的渲染空间，不受外部布局的影响"></a>BFC块级格式化上下文：独立的渲染空间，不受外部布局的影响</h2><ol>
<li>CSS2.1规定<strong>BFC的条件</strong>至少满足以下一条：</li>
</ol>
<ul>
<li>float值不为none;</li>
<li>overflow不为visible，可取（hidden,scroll,hidden）</li>
<li>display值为inline-block，table-cell，table-caption，flex，inline-flex；</li>
<li>position的值为absolute或fixed;</li>
</ul>
<ol start="2">
<li><strong>BFC的特点</strong>：</li>
</ol>
<ul>
<li>在同一个BFC区域，其内部盒子总是垂直排列，左对齐；</li>
</ul>
<ol start="3">
<li><strong>BFC的应用场景</strong>：</li>
</ol>
<ul>
<li>用于解决margin重叠问题；</li>
<li>用于两栏布局，BFC不会和浮动盒子float叠加；</li>
<li>用于解决<code>父元素塌陷</code>，清除浮动元素，计算BFC高度时，浮动元素会参与计算；<br><code>父元素塌陷</code>：父元素高度一般由子元素撑开，当子元素float后，父元素高度为0；</li>
</ul>
<h2 id="flex（弹性布局）"><a href="#flex（弹性布局）" class="headerlink" title="flex（弹性布局）"></a>flex（弹性布局）</h2><p>display:flex<br>容器属性：<br>flex-direction:<br>flex-wrap:<br>flex-flow:<br>justify-content:<br>align-items:</p>
<p>项目属性：<br>order:越小越靠前<br>flex-grow:当有剩余空间时是否放大  0（不放大）<br>flex-shrink:当空间不足时是否缩小  1（缩小）<br>flex-basis:设置项目宽度</p>
<p>flex: 0 1 auto(默认值)<br>flex:auto ====》 flex: 1 1 auto<br>flex:none ====&gt;  flex: 0 0 auto</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/09/02/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/">前端优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-02</time><div class="content"><h2 id="优化首屏加载慢"><a href="#优化首屏加载慢" class="headerlink" title="优化首屏加载慢"></a>优化首屏加载慢</h2><ol>
<li><p>图片懒加载</p>
</li>
<li><p>使用CDN加载静态资源</p>
</li>
<li><p>提升页面渲染速度：css样式文件写在头部；js文件放在末尾，或使用async加载，避免js执行阻塞渲染；</p>
</li>
<li><p>服务器速度优化：<br>（1）启用服务器Gzip压缩功能；</p>
<p>（2）开启网站缓存</p>
</li>
</ol>
<h2 id="减少回流重绘"><a href="#减少回流重绘" class="headerlink" title="减少回流重绘"></a>减少回流重绘</h2><p>回流：节点的几何属性或布局发生改变<br>重绘：节点的样式改变但不影响布局，比如color,visiblity</p>
<p><strong>重绘不一定回流，回流一定会重绘</strong></p>
<ol>
<li><p>批量修改DOM或者样式，使用document.createDocumentFragment()缓存操作；</p>
</li>
<li><p>利用display:none隐藏元素，进行操作后再使其可见；</p>
</li>
<li><p>直接改变className</p>
</li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By John Doe</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>