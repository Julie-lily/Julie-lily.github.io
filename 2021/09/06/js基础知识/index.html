<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="js基础知识"><meta name="keywords" content=""><meta name="author" content="julie"><meta name="copyright" content="julie"><title>js基础知识 | Julie's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">js的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">判断数据类型的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E7%9A%84%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">JavaScript的内置对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegExp"><span class="toc-number">4.</span> <span class="toc-text">js正则表达式RegExp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">5.</span> <span class="toc-text">var、let和const的区别，变量提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">new函数的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">8.</span> <span class="toc-text">防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81API"><span class="toc-number">9.</span> <span class="toc-text">Array数组的常见API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">10.</span> <span class="toc-text">数组遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86"><span class="toc-number">11.</span> <span class="toc-text">对象遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-%E3%80%81for-of-%E3%80%81Object-keys-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">for in 、for of 、Object.keys()的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">13.</span> <span class="toc-text">对象的浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">14.</span> <span class="toc-text">ES异步编程的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8Aapi"><span class="toc-number">15.</span> <span class="toc-text">Promise的作用及api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator%E5%92%8CAsync%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">Generator和Async的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">实现继承的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">18.</span> <span class="toc-text">图片懒加载的实现，以及原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%90%AB%E4%B9%89%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">19.</span> <span class="toc-text">闭包的含义及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">20.</span> <span class="toc-text">原型以及原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E5%8F%88%E7%A7%B0%E4%B8%BA%E4%BD%9C%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">21.</span> <span class="toc-text">作用域，又称为作用上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-number">22.</span> <span class="toc-text">this指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6event-loop"><span class="toc-number">23.</span> <span class="toc-text">事件循环机制event loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">24.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">25.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">26.</span> <span class="toc-text">常见的内存泄漏的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%89%8B%E6%AE%B5"><span class="toc-number">27.</span> <span class="toc-text">前端常见的攻击手段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%8C%E8%B7%A8%E5%9F%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%8CJsonP"><span class="toc-number">28.</span> <span class="toc-text">浏览器的同源策略，跨域怎么解决，JsonP</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">julie</div><div class="author-info__description text-center">�Ȱ�����Ȱ���ʳ</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(./img/blog2.img)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Julie's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">js基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-06</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h2><p>基础数据类型：</p>
<ol>
<li>Number：包括整数和浮点数</li>
</ol>
<ul>
<li>isNaN()函数用于检查是否为非数字值，例如：isNaN(123) ===&gt;false</li>
<li>NaN!=NaN</li>
</ul>
<ol start="2">
<li>String：字符串有length属性</li>
</ol>
<ul>
<li>转型函数String():适用于任何数据类型，例如：String(null)===&gt;’null’</li>
<li>toString()方法：null和undefined没有toString()方法</li>
</ul>
<ol start="3">
<li><p>Boolean</p>
</li>
<li><p>Undefined</p>
</li>
<li><p>Null</p>
</li>
<li><p>Symbol(独一无二的值)</p>
</li>
<li><p>BigInt</p>
</li>
</ol>
<p>复杂数据类型：Object</p>
<span id="more"></span>

<h2 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h2><ol>
<li>typeof<br>例如： </li>
</ol>
<ul>
<li>typeof 123 ==”string”</li>
<li>typeof null == “object”</li>
</ul>
<ol start="2">
<li>instanceof:判断构造函数的原型是否在被检测对象的原型链上<br>例如：</li>
</ol>
<ul>
<li>123 instanceof Number  ; // false</li>
<li>‘foo’ instanceof String; // false</li>
</ul>
<p>原理：如何判断A是不是B的实例？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function _instanceof(a,b)&#123;</span><br><span class="line">    let L=a._proto_;</span><br><span class="line">    let R =b.prototype;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if(L==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L==R)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            L=L._proto_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Object.prototype.toString.call()   “[object Object]”</li>
</ol>
<ol start="4">
<li>constructor：不能判断null和undeifned</li>
</ol>
<h2 id="JavaScript的内置对象"><a href="#JavaScript的内置对象" class="headerlink" title="JavaScript的内置对象"></a>JavaScript的内置对象</h2><ul>
<li>数据封装类对象: Object Array Boolean Number String</li>
<li>其他对象：Function Arguments Math Date RegExp Error</li>
</ul>
<h2 id="js正则表达式RegExp"><a href="#js正则表达式RegExp" class="headerlink" title="js正则表达式RegExp"></a>js正则表达式RegExp</h2><ul>
<li>i 大小写不敏感</li>
<li>g 执行全局匹配</li>
</ul>
<p>RegExp.test(string):检测是否匹配，返回true或false</p>
<p>RegExp.exec(string):检索匹配结果，返回数组</p>
<p>string.match(RegExp):返回匹配的数组</p>
<p>string.replace(,)</p>
<h2 id="var、let和const的区别，变量提升"><a href="#var、let和const的区别，变量提升" class="headerlink" title="var、let和const的区别，变量提升"></a>var、let和const的区别，变量提升</h2><ol>
<li><p>var声明的变量会挂载到window上，而let和const声明的变量不会；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=100;</span><br><span class="line">console.log(a,window.a);  //100 100</span><br><span class="line"></span><br><span class="line">let b=10;</span><br><span class="line">console.log(b,window.b);  //10 undefined</span><br><span class="line"></span><br><span class="line">let c=1;</span><br><span class="line">console.log(c,window.c);  //1 undefined</span><br></pre></td></tr></table></figure></li>
<li><p>var变量存在变量提升，而let和const没有；</p>
</li>
<li><p>let和const声明形成块作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(1)&#123;</span><br><span class="line">    var a=100;</span><br><span class="line">    let b=10;</span><br><span class="line">    const c=1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a,b,c) //100 报错:b is not defined  报错：c is not defined</span><br></pre></td></tr></table></figure></li>
<li><p>同一作用域内，let和const不可重复声明;</p>
</li>
<li><p>暂存死区；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">if(1)&#123;</span><br><span class="line">    a = 10;</span><br><span class="line">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>const一旦声明变量，必须复制，且声明后不可修改其值；</p>
</li>
</ol>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><ol>
<li>this，箭头函数没有自己的this；</li>
<li>arguments，不能使用arguments，改用rest代替；</li>
<li>原型，没有prototype，无法作为构造函数；</li>
<li>yeild</li>
</ol>
<h2 id="new函数的具体实现"><a href="#new函数的具体实现" class="headerlink" title="new函数的具体实现"></a>new函数的具体实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function _new(constructor,...args)&#123;</span><br><span class="line">    let obj = &#123;&#125;;//新建一个空对象</span><br><span class="line">    obj._proto_ = constructor.prototype;//原型链连接</span><br><span class="line">    let res = constructor.apply(obj,...args);//改变this指向</span><br><span class="line">    return res instanceof Object ? res:obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p><strong>debounce（防抖）</strong>:触发高频事件后，N秒内函数只会执行一次，若N秒内再次触发高频事件，则重新计时;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer = null;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(fn,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<ul>
<li>搜索框输入查询</li>
<li>浏览器窗口缩放</li>
<li>按钮提交</li>
<li>表单验证</li>
</ul>
<p><strong>throttle（节流）</strong>:高频事件多次触发，但在N秒内只会执行一次，会稀释函数的执行频率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn,delay)&#123;</span><br><span class="line">    let timer=null;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        if(timer)return false;</span><br><span class="line">        timer = setTimeout(()=&gt;&#123;</span><br><span class="line">            fn();</span><br><span class="line">            timer=null;</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<ul>
<li>高频表单提交</li>
<li>滚动加载onScroll</li>
<li>拖拽事件</li>
</ul>
<h2 id="Array数组的常见API"><a href="#Array数组的常见API" class="headerlink" title="Array数组的常见API"></a>Array数组的常见API</h2><h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><ul>
<li>for(let i=0;i &lt; arr.length;i++){}</li>
<li>forEach:不能break或return;遍历时会跳过空值;</li>
<li>for in:会跳过空值</li>
<li>for of:</li>
</ul>
<h2 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h2><ul>
<li>for in</li>
<li>for of Object.keys(obj)</li>
<li>for of Object.values(obj)</li>
<li>for of Object.entries(obj)</li>
</ul>
<h2 id="for-in-、for-of-、Object-keys-的区别"><a href="#for-in-、for-of-、Object-keys-的区别" class="headerlink" title="for in 、for of 、Object.keys()的区别"></a>for in 、for of 、Object.keys()的区别</h2><p><code>return 语句只能在函数体中，否则会报错</code></p>
<ul>
<li>for in：可遍历数组或对象的属性（随机遍历）</li>
</ul>
<ol>
<li><p>遍历数组：除了会遍历数组元素，还会遍历自定义可枚举的属性，以及原型链上可枚举的属性；</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.sayLength = function()&#123;</span><br><span class="line">    console.log(this.length);</span><br><span class="line">&#125;//原型链上</span><br><span class="line"></span><br><span class="line">let arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];</span><br><span class="line">arr.name = &#x27;数组&#x27;; //自定义属性</span><br><span class="line"></span><br><span class="line">Object.defineProperties(arr,&#123;</span><br><span class="line">    type:&#123;</span><br><span class="line">        value:true,</span><br><span class="line">        writable:true,</span><br><span class="line">        enumerable:true</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for(let i in arr)&#123;</span><br><span class="line">    console.log(i); //0,1,2,3,name,type,sayLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>Object.keys():遍历对象属性<br><code>和 for in 的区别在于：不能遍历原型链上的属性</code></li>
</ul>
<ul>
<li>for of（ES6新语法）:可遍历拥有iterator迭代器对象的集合；支持遍历<strong>数组</strong>、<strong>类对象</strong>、<strong>字符串</strong>、<strong>Set对象</strong>、<strong>Map对象</strong>；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [0,1,2,3];</span><br><span class="line">for(let i of arr)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person=&#123;</span><br><span class="line">    name:&#x27;1&#x27;,</span><br><span class="line">    age:12</span><br><span class="line">&#125;</span><br><span class="line">for(let key of Object.keys(person))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">for(let [key,value] of Object.entries(person))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象的浅拷贝和深拷贝"><a href="#对象的浅拷贝和深拷贝" class="headerlink" title="对象的浅拷贝和深拷贝"></a>对象的浅拷贝和深拷贝</h2><h2 id="ES异步编程的发展史"><a href="#ES异步编程的发展史" class="headerlink" title="ES异步编程的发展史"></a>ES异步编程的发展史</h2><h2 id="Promise的作用及api"><a href="#Promise的作用及api" class="headerlink" title="Promise的作用及api"></a>Promise的作用及api</h2><p><strong>作用：</strong> Promise用于解决回调地狱（嵌套过多）;</p>
<ul>
<li>Promise.all()：只在所有请求成功之后才会做出响应<br>应用场景：发起多个请求时</li>
</ul>
<ul>
<li>Promise.race():</li>
</ul>
<ul>
<li>Promise.finally():</li>
</ul>
<h2 id="Generator和Async的区别"><a href="#Generator和Async的区别" class="headerlink" title="Generator和Async的区别"></a>Generator和Async的区别</h2><h2 id="实现继承的方式"><a href="#实现继承的方式" class="headerlink" title="实现继承的方式"></a>实现继承的方式</h2><ol>
<li><p>原型继承</p>
</li>
<li><p>构造继承</p>
</li>
<li><p>组合继承</p>
</li>
<li><p>寄生式继承</p>
</li>
<li><p>寄生组合式继承</p>
</li>
</ol>
<h2 id="图片懒加载的实现，以及原因"><a href="#图片懒加载的实现，以及原因" class="headerlink" title="图片懒加载的实现，以及原因"></a>图片懒加载的实现，以及原因</h2><p>intersectionObserver</p>
<h2 id="闭包的含义及作用"><a href="#闭包的含义及作用" class="headerlink" title="闭包的含义及作用"></a>闭包的含义及作用</h2><p>闭包：有权访问另一个函数作用域的函数；<br>作用：为了设计私有的方法和变量；<br>优点：<br>（1）避免全局污染，隐藏变量；</p>
<p>缺点：<br>（1）常驻内存，使用不当容易造成内存泄漏；<br>（2）内存浪费；</p>
<h2 id="原型以及原型链"><a href="#原型以及原型链" class="headerlink" title="原型以及原型链"></a>原型以及原型链</h2><ul>
<li>原型的概念：每一个javascript对象（除了null）创建时，就会与之关联另一个对象，这个对象即原型；每个对象都会从原型中“继承”属性；</li>
</ul>
<p><code>当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj);</code></p>
<p><img src="/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="原型链"></p>
<p>（1）每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针constructor；<br>（2）实例都包含一个指向原型对象的内部指针；</p>
<h2 id="作用域，又称为作用上下文"><a href="#作用域，又称为作用上下文" class="headerlink" title="作用域，又称为作用上下文"></a>作用域，又称为作用上下文</h2><p><strong>作用域</strong>的作用是用于解析标识符，隔离变量；</p>
<p>当函数被创建（定义）时，会将this,arguments,命名参数和该函数中局部变量都保存在当前作用域内；</p>
<p><strong>作用域链</strong>的作用：保证对执行环境有权访问的所有变量和函数的有序访问；</p>
<p>当执行一段JS代码时，JS引擎会创建一个作用域，在页面加载后首先会创建一个全局作用域，然后每执行一个函数，就会建立一个对应的作用域，从而形成一个作用域链。</p>
<p>执行环境(execution context)定义了变量或者函数有权访问的其他数据，每个执行环境都有一个与之关联的<code>变量对象</code>(variable object)，执行环境中定义的变量和函数就保存在这个变量对象中；<br>全局执行环境是最外围的一个执行环境，通常被认为是window对象;<br>执行环境和变量对象在<code>运行函数</code>时生成;<br>执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)</p>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><ol>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li>new绑定</li>
</ol>
<h2 id="事件循环机制event-loop"><a href="#事件循环机制event-loop" class="headerlink" title="事件循环机制event loop"></a>事件循环机制event loop</h2><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>//取消事件冒泡</p>
<ul>
<li><p>e.stopPropagation()</p>
</li>
<li><p>e.cancelBubble = true</p>
</li>
</ul>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ol>
<li><p>标记清除</p>
</li>
<li><p>引用计数</p>
</li>
</ol>
<h2 id="常见的内存泄漏的原因"><a href="#常见的内存泄漏的原因" class="headerlink" title="常见的内存泄漏的原因"></a>常见的内存泄漏的原因</h2><ol>
<li>全局变量</li>
<li>闭包</li>
<li>循环引用</li>
<li>dom清除或删除时，绑定的事件未清除</li>
<li>未及时清除计时器或回调函数</li>
</ol>
<h2 id="前端常见的攻击手段"><a href="#前端常见的攻击手段" class="headerlink" title="前端常见的攻击手段"></a>前端常见的攻击手段</h2><ul>
<li><code>XSS预防</code>（跨站脚本攻击Cross-Site Scripting）：原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码,当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的;</li>
</ul>
<ol>
<li><p>非持久型XSS（反射型XSS）:一般是通过向用户发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意脚本代码参数被解析、执行；</p>
</li>
<li><p>持久型XSS(存储型XSS)：一般存在与form表单提交等交互功能中，比如文章留言，提交文本信息等；</p>
</li>
</ol>
<p>黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行；</p>
<p><strong>防御手段</strong>：</p>
<ol>
<li>转义字符，用户的输入永远不可信；</li>
<li>服务端设置Cookie的HttpOnly属性，预防XSS攻击获取cookie；</li>
<li>CSP建立白名单，明确哪些外部资源可以加载和执行；</li>
</ol>
<hr>
<ul>
<li><code>CSRF预防(跨站请求伪造)</code>:是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作;<br>举例说明CSRF攻击的具体过程，攻击者能够跨站攻击的本质是什么？CSRF怎么防御?</li>
</ul>
<p>完成 CSRF 攻击必须要有三个条件：</p>
<ul>
<li>用户已经登录了站点 A，并在本地记录了 cookie;</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A);</li>
<li>站点 A 没有做任何 CSRF 防御;</li>
</ul>
<p><strong>防御手段</strong></p>
<ol>
<li>设置验证码，强制用户进行交互；</li>
<li>Referer Check，通过检查请求的来源来防御CSRF攻击，在Http头中有一个字段referer，记录了该http请求的来源地址；</li>
<li>token验证，发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token；</li>
</ol>
<p>服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等；</p>
<hr>
<ul>
<li><code>SQL注入</code>：构建SQL查询</li>
</ul>
<p>所谓的万能密码,本质上就是SQL注入的一种利用方式；</p>
<p><strong>防御</strong>：</p>
<ul>
<li>严格限制Web应用的数据库操作权限；</li>
<li>后端代码检查输入的数据是否符合预期，使用正则表达式匹配处理；</li>
<li>对进入数据库的特殊字符（’,”,&lt;,&gt;,&amp;,*,;等）进行转义处理或编码处理；</li>
</ul>
<h2 id="浏览器的同源策略，跨域怎么解决，JsonP"><a href="#浏览器的同源策略，跨域怎么解决，JsonP" class="headerlink" title="浏览器的同源策略，跨域怎么解决，JsonP"></a>浏览器的同源策略，跨域怎么解决，JsonP</h2><p>JsonP浏览器返回的数据是什么，回调函数写在哪里？script标签的src里面</p>
<p><strong>同源策略：</strong>是一种约定，是浏览器最核心也最基本的安全功能;会阻止一个域的javascript脚本和另外一个域的内容进行交互;</p>
<ul>
<li>同源策略限制的内容：<br>（1）Cookie、localStorage、sessionStorage；<br>（2）DOM节点；<br>（3）Ajax请求；</li>
</ul>
<p><code>当协议、域名和端口任意一个不同时，就会发生跨域;</code></p>
<p><strong>跨域的解决方法：</strong><br>（1）document.domain设置，设为相同值，即可共享Cookie（适用于主域相同，子域不同的页面）;</p>
<p>（2）window.postMessage()通信<br>window.addEventListener(‘message’,function(e){</p>
<p>});</p>
<p>（3）JSONP,服务端和客户端通信跨源通信的常用方法；</p>
<ul>
<li>优点：简单适用，兼容性强</li>
<li>缺点：只支持GET请求；</li>
<li>核心思想：通过添加一个<script>元素，利用src属性不受跨域限制，在服务端连接的 参数 中加入callback函数，服务端将数据放入该回调函数中；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原生实现</span><br><span class="line">&lt;script src=&quot;http://test.com/index.html?callback=test1&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;scipt type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    //回调函数处理服务端返回数据</span><br><span class="line">    function test1(res)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（4）CORS(跨域资源共享Cross-Origin Resource Sharing)</p>
<ul>
<li>普通跨域请求：只需服务器端设置Access-Control-Allow-Origin<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务端设置</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;);</span><br><span class="line">&#x27;Access-Control-Allow-Credentials&#x27;: &#x27;true&#x27;,     // 后端允许发送Cookie</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>（5）webpack本地代理：代理服务器，转发响应，转发请求；</p>
<p>webpack.config.js中利用WebpackDevServer配置本地代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer&#123;</span><br><span class="line">     port:8080,</span><br><span class="line">     proxy:&#123;</span><br><span class="line">         &quot;/api&quot;:&#123;</span><br><span class="line">             target:&quot;http://~&quot;     //后端接口</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）Nignx反向代理：搭建一个中转 nginx 服务器，用于转发请求；在一个服务器上配置<strong>多个前缀</strong>来转发http/https请求到多个真实的服务器即可；</p>
<p>下载nginx，修改nginx目录下nginx.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>（7）websocket：是HTML5的一种持久化协议，实现浏览器和服务器的全双工通信，WebSocket基于TCP协议，在建立连接后，服务端和客户端均能主动向对方发送数据或接收数据；</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">julie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/06/js基础知识/">http://example.com/2021/09/06/js基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Julie's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/06/webpack%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"><i class="fa fa-chevron-left">  </i><span>webpack相关知识</span></a></div><div class="next-post pull-right"><a href="/2021/09/05/CSS3%E7%9B%B8%E5%85%B3/"><span>CSS3相关</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(./img/blog2.img)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By julie</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>